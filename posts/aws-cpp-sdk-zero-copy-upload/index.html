<!doctype html><html lang=en><head><title>How to perform zero-copy S3 uploads with the AWS C++ SDK :: OpenCore Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="If you&amp;rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (as other developers did). You can write your own streambuf wrapper to do so, but if you&amp;rsquo;re already using boost in your project, boost::interprocess::bufferstream is a very straightforward way to do it:"><meta name=keywords content="aws,s3"><meta name=robots content="noodp"><link rel=canonical href=https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/><link rel=stylesheet href=https://blog.opencore.ch/assets/style.css><link rel=stylesheet href=https://blog.opencore.ch/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://blog.opencore.ch/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://blog.opencore.ch/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="romanboehr"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="How to perform zero-copy S3 uploads with the AWS C++ SDK :: OpenCore Blog"><meta property="og:description" content="If you&amp;rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (as other developers did). You can write your own streambuf wrapper to do so, but if you&amp;rsquo;re already using boost in your project, boost::interprocess::bufferstream is a very straightforward way to do it:"><meta property="og:url" content="https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/"><meta property="og:site_name" content="How to perform zero-copy S3 uploads with the AWS C++ SDK"><meta property="og:image" content="https://blog.opencore.ch"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2021-12-11 00:00:00 +0000 UTC"></head><body class=blue><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>OpenCore GmbH</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/>How to perform zero-copy S3 uploads with the AWS C++ SDK</a></h1><div class=post-meta><span class=post-date>2021-12-11</span>
<span class=post-author>:: Roman Böhringer</span></div><span class=post-tags>#<a href=https://blog.opencore.ch/tags/cpp/>cpp</a>&nbsp;</span><div class=post-content><div><p>If you&rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (<a href=https://github.com/aws/aws-sdk-cpp/issues/64>as</a> <a href=https://github.com/aws/aws-sdk-cpp/issues/533>other</a> <a href=https://github.com/aws/aws-sdk-cpp/issues/785>developers</a> <a href=https://github.com/aws/aws-sdk-cpp/issues/1430>did</a>).
You can write your own <code>streambuf</code> wrapper to do so, but if you&rsquo;re already using <code>boost</code> in your project, <code>boost::interprocess::bufferstream</code> is a very straightforward way to do it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> buf;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>size_t len;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Aws<span style=color:#f92672>::</span>IOStream<span style=color:#f92672>&gt;</span> data <span style=color:#f92672>=</span> Aws<span style=color:#f92672>::</span>MakeShared<span style=color:#f92672>&lt;</span>boost<span style=color:#f92672>::</span>interprocess<span style=color:#f92672>::</span>bufferstream<span style=color:#f92672>&gt;</span>(TAG, buf, buf_len);
</span></span></code></pre></div><p><code>data</code> can then be used as usual:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Aws<span style=color:#f92672>::</span>S3<span style=color:#f92672>::</span>Model<span style=color:#f92672>::</span>PutObjectRequest request;
</span></span><span style=display:flex><span>request.WithBucket(bucket_name).WithKey(name);
</span></span><span style=display:flex><span>request.SetBody(data);
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> outcome <span style=color:#f92672>=</span> client<span style=color:#f92672>-&gt;</span>PutObject(request);
</span></span></code></pre></div></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://blog.opencore.ch/posts/metricbeat-docker-swarm-setup/><span class=button__icon>←</span>
<span class=button__text>Setting up Metricbeat on a Docker Swarm Cluster</span></a></span>
<span class="button next"><a href=https://blog.opencore.ch/posts/unicode-normalization-forms/><span class=button__text>Unicode Normalization Forms: When ö != ö</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 <a href=https://twitter.com/romanboehr/ target=_blank>Roman Böhringer</a></span></div></div></footer><script src=https://blog.opencore.ch/assets/main.js></script>
<script src=https://blog.opencore.ch/assets/prism.js></script></div></body></html>