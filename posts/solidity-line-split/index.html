<!doctype html><html lang=en><head><title>Splitting a string into multiple lines in Solidity: How hard can it be? :: OpenCore Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?
Let&amp;rsquo;s assume that we use an external function which takes a string and returns a string[] array containing the individual lines. A straight-forward implementation looks like this:
javascript First approach function lineSplit(string memory text) external pure returns (string[] memory) { bytes memory textBytes = bytes(text); uint lengthInBytes = textBytes."><meta name=keywords content="solidity"><meta name=robots content="noodp"><link rel=canonical href=https://blog.opencore.ch/posts/solidity-line-split/><link rel=stylesheet href=https://blog.opencore.ch/assets/style.css><link rel=stylesheet href=https://blog.opencore.ch/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://blog.opencore.ch/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://blog.opencore.ch/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="romanboehr"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Splitting a string into multiple lines in Solidity: How hard can it be? :: OpenCore Blog"><meta property="og:description" content="For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?"><meta property="og:url" content="https://blog.opencore.ch/posts/solidity-line-split/"><meta property="og:site_name" content="Splitting a string into multiple lines in Solidity: How hard can it be?"><meta property="og:image" content="https://blog.opencore.ch"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-02-24 00:00:00 +0000 UTC"></head><body class=blue><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>OpenCore GmbH</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.opencore.ch/posts/solidity-line-split/>Splitting a string into multiple lines in Solidity: How hard can it be?</a></h1><div class=post-meta><span class=post-date>2023-02-24</span>
<span class=post-author>:: Roman Böhringer</span></div><span class=post-tags>#<a href=https://blog.opencore.ch/tags/solidity/>solidity</a>&nbsp;</span><div class=post-content><div><p>For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?</p><p>Let&rsquo;s assume that we use an external function which takes a <code>string</code> and returns a <code>string[]</code> array containing the individual lines. A straight-forward implementation looks like this:</p><div class=collapsable-code><input id=413726895 type=checkbox>
<label for=413726895><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>First approach</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
    function lineSplit(string memory text) external pure returns (string[] memory) {
        bytes memory textBytes = bytes(text);
        uint lengthInBytes = textBytes.length;
        require(lengthInBytes &gt; 0, &#34;Invalid length&#34;);
        uint lines = (lengthInBytes - 1) / 40 &#43; 1;
        string[] memory strLines = new string[](lines);
        bytes memory bytesLines = new bytes(40);
        for (uint i; i &lt; lengthInBytes; &#43;&#43;i) {
            if (i &gt; 0 &amp;&amp; i % 40 == 0) {
                strLines[i / 40 - 1] = string(bytesLines);
                bytesLines = new bytes(40);
            }
            bytes1 character = textBytes[i];
            bytesLines[i % 40] = character;
        }
        strLines[lines - 1] = string(bytesLines);
        return strLines;
    }
</code></pre></div><p>When we pass a few strings such as &ldquo;A&rdquo;, &ldquo;AAA&rdquo;, or &ldquo;A&rdquo; * 41, the results looks ok. However, what if our string contains a character like è? When passing the string <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAè</code>, we see the first problem: The function returns two lines, but the last character of the first line and the first of the second line are invalid. This happens because è is a multi-byte character with the UTF-8 encoding <code>0xC3 0xA8</code>, but our implementation splits on bytes. We therefore need to adjust our implementation such that it does not split between multi-byte characters. This introduces a few complications:</p><ul><li>We no longer split the string into 40 characters, but (roughly) 40 bytes. While this is fine for our implementation, it may not be for others, in which case you would need to count the actual characters.</li><li>Each line can now have a different length (in bytes) as we need to include a few extra bytes (up to 3 extra bytes for 4 byte characters) when there is a multi-byte character at the end.</li></ul><p>Ok, let&rsquo;s rewrite the function such that it handles these complications correctly:</p><div class=collapsable-code><input id=397245168 type=checkbox>
<label for=397245168><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>Second approach</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
    function lineSplit2(string memory text) external pure returns (string[] memory) {
        bytes memory textBytes = bytes(text);
        uint lengthInBytes = textBytes.length;
        require(lengthInBytes &gt; 0, &#34;Invalid length&#34;);
        uint lines = (lengthInBytes - 1) / 40 &#43; 1;
        string[] memory strLines = new string[](lines);
        bool prevByteWasContinuation;
        uint256 insertedLines;
        bytes memory bytesLines = new bytes(43);
        uint bytesOffset;
        for (uint i; i &lt; lengthInBytes; &#43;&#43;i) {
            bytes1 character = textBytes[i];
            bytesLines[bytesOffset] = character;
            bytesOffset&#43;&#43;;
            if ((i &gt; 0 &amp;&amp; (i &#43; 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {
                bytes1 nextCharacter;
                if (i != lengthInBytes - 1) {
                    nextCharacter = textBytes[i &#43; 1];
                }
                if (nextCharacter &amp; 0xC0 == 0x80) {
                    // Unicode continuation byte, top two bits are 10
                    prevByteWasContinuation = true;
                } else {
                    // Store the actual length
                    assembly {
                        mstore(bytesLines, bytesOffset)
                    }
                    strLines[insertedLines&#43;&#43;] = string(bytesLines);
                    bytesLines = new bytes(43);
                    prevByteWasContinuation = false;
                    bytesOffset = 0;
                }
            }
        }
        return strLines;
    }
</code></pre></div><p>Unicode continuation bytes are recognizable by the two top bits (which are only <code>10</code> for continuation bytes) and we can use inline assembly to change the length of the bytes array to the correct length before casting it to a string.</p><p>Strings like <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAè</code> or <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAèè</code> are now correctly handled, nice! We can even use the function for emojis, a string like 😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀 is correctly handled. However, something weird happens when we pass the string 👨‍👩‍👧‍👧👨‍👩‍👧‍👧👨‍👩‍👧‍👧. The output of the function is [👨‍👩‍👧‍👧👨‍👩‍👧, ‍👧👨‍👩‍👧‍👧]</p><p>Wait what, our function removed the daughter from the second family??? This happens because emojis like 👨‍👩‍👧‍👧 are composed of 4 individual emojis that are stitched together with a zero width joiner (<code>0xE2 0x80 0x8D</code>) and we potentially break on these joiners (which are individual UTF8 characters).</p><p>Let&rsquo;s change the function such that it does not do that. Note that this also makes the lines potentially much longer (in bytes), so we have to allocate a larger buffer for it:</p><div class=collapsable-code><input id=142798356 type=checkbox>
<label for=142798356><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>Third approach</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
    function lineSplit3(string memory text) external pure returns (string[] memory) {
        bytes memory textBytes = bytes(text);
        uint lengthInBytes = textBytes.length;
        require(lengthInBytes &gt; 0, &#34;Invalid length&#34;);
        uint lines = (lengthInBytes - 1) / 40 &#43; 1;
        string[] memory strLines = new string[](lines);
        bool prevByteWasContinuation;
        uint256 insertedLines;
        bytes memory bytesLines = new bytes(80);
        uint bytesOffset;
        for (uint i; i &lt; lengthInBytes; &#43;&#43;i) {
            bytes1 character = textBytes[i];
            bytesLines[bytesOffset] = character;
            bytesOffset&#43;&#43;;
            if ((i &gt; 0 &amp;&amp; (i &#43; 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {
                bytes1 nextCharacter;
                if (i != lengthInBytes - 1) {
                    nextCharacter = textBytes[i &#43; 1];
                }
                if (nextCharacter &amp; 0xC0 == 0x80) {
                    // Unicode continuation byte, top two bits are 10
                    prevByteWasContinuation = true;
                } else {
                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, 👨‍👧‍👦 could become 👨&gt;‍👧‍👦
                    if (
                        // Note that we do not need to check i &lt; lengthInBytes - 4, because we assume that it&#39;s a valid UTF8 string and these prefixes imply that another byte follows
                        (nextCharacter == 0xE2 &amp;&amp; textBytes[i &#43; 2] == 0x80 &amp;&amp; textBytes[i &#43; 3] == 0x8D) ||
                        (i &gt;= 2 &amp;&amp;
                            textBytes[i - 2] == 0xE2 &amp;&amp;
                            textBytes[i - 1] == 0x80 &amp;&amp;
                            textBytes[i] == 0x8D)
                    ) {
                        prevByteWasContinuation = true;
                        continue;
                    }
                    // Store the actual length
                    assembly {
                        mstore(bytesLines, bytesOffset)
                    }
                    strLines[insertedLines&#43;&#43;] = string(bytesLines);
                    bytesLines = new bytes(80);
                    prevByteWasContinuation = false;
                    bytesOffset = 0;
                }
            }
        }
        return strLines;
    }
</code></pre></div><p>Our function now returns [👨‍👩‍👧‍👧👨‍👩‍👧‍👧, 👨‍👩‍👧‍👧]. So did we develop the perfect Solidity line splitting function and can be proud? Let&rsquo;s do a last test with the string &ldquo;🤦🏿🤦🏿🤦🏿🤦🏿abcd🤦🏿&rdquo;. The function returns [🤦🏿🤦🏿🤦🏿🤦🏿abcd🤦, 🏿], which is not what we want! The problem here is that there is a skin tone modifier (without a zero width joiner) after the 🤦 and we split just between those characters. All right, let&rsquo;s fix that by avoiding splits before a <code>0xF0 0x9F 0x8F XY</code> where <code>XY</code> is <code>0xBB</code>, <code>0xBC</code>, <code>0xBD</code>, <code>0xBE</code>, <code>0xBF</code> (all possible skin tone modifiers):</p><div class=collapsable-code><input id=728614395 type=checkbox>
<label for=728614395><span class=collapsable-code__language>javascript</span>
<span class=collapsable-code__title>Fourth approach</span>
<span class=collapsable-code__toggle data-label-expand=△ data-label-collapse=▽></span></label><pre class=language-javascript><code>
    function lineSplit4(string memory text) external pure returns (string[] memory) {
        bytes memory textBytes = bytes(text);
        uint lengthInBytes = textBytes.length;
        require(lengthInBytes &gt; 0, &#34;Invalid length&#34;);
        uint lines = (lengthInBytes - 1) / 40 &#43; 1;
        string[] memory strLines = new string[](lines);
        bool prevByteWasContinuation;
        uint256 insertedLines;
        bytes memory bytesLines = new bytes(80);
        uint bytesOffset;
        for (uint i; i &lt; lengthInBytes; &#43;&#43;i) {
            bytes1 character = textBytes[i];
            bytesLines[bytesOffset] = character;
            bytesOffset&#43;&#43;;
            if ((i &gt; 0 &amp;&amp; (i &#43; 1) % 40 == 0) || prevByteWasContinuation || i == lengthInBytes - 1) {
                bytes1 nextCharacter;
                if (i != lengthInBytes - 1) {
                    nextCharacter = textBytes[i &#43; 1];
                }
                if (nextCharacter &amp; 0xC0 == 0x80) {
                    // Unicode continuation byte, top two bits are 10
                    prevByteWasContinuation = true;
                } else {
                    // Do not split when the prev. or next character is a zero width joiner. Otherwise, 👨‍👧‍👦 could become 👨&gt;‍👧‍👦
                    // Furthermore, do not split when next character is skin tone modifier to avoid 🤦‍♂️\n🏻
                    if (
                        // Note that we do not need to check i &lt; lengthInBytes - 4, because we assume that it&#39;s a valid UTF8 string and these prefixes imply that another byte follows
                        (nextCharacter == 0xE2 &amp;&amp; textBytes[i &#43; 2] == 0x80 &amp;&amp; textBytes[i &#43; 3] == 0x8D) ||
                        (nextCharacter == 0xF0 &amp;&amp;
                            textBytes[i &#43; 2] == 0x9F &amp;&amp;
                            textBytes[i &#43; 3] == 0x8F &amp;&amp;
                            uint8(textBytes[i &#43; 4]) &gt;= 187 &amp;&amp;
                            uint8(textBytes[i &#43; 4]) &lt;= 191) ||
                        (i &gt;= 2 &amp;&amp;
                            textBytes[i - 2] == 0xE2 &amp;&amp;
                            textBytes[i - 1] == 0x80 &amp;&amp;
                            textBytes[i] == 0x8D)
                    ) {
                        prevByteWasContinuation = true;
                        continue;
                    }
                    // Store the actual length
                    assembly {
                        mstore(bytesLines, bytesOffset)
                    }
                    strLines[insertedLines&#43;&#43;] = string(bytesLines);
                    bytesLines = new bytes(80);
                    prevByteWasContinuation = false;
                    bytesOffset = 0;
                }
            }
        }
        return strLines;
    }
</code></pre></div><p>Now, this case is handled correctly as well. So is this the perfect Solidity line splitting algorithm that handles every input perfectly? No, definitely not. Unicode Line Breaking is very involved and <a href=https://unicode.org/reports/tr14/>there is a 25 paper annex on this topic</a>. While the algorithm handles some (commonly occuring) edge cases correctly, there are definitely others that could be problematic, especially with text in other characters (e.g., chinese ones).</p><p><strong>Note that the code in this post is not thoroughly tested and only used for illustrative purposes. Usage at your own risk</strong></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://blog.opencore.ch/posts/boost-python-cmake/><span class=button__text>Boost.Python: A minimal CMake Config</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 <a href=https://twitter.com/romanboehr/ target=_blank>Roman Böhringer</a></span></div></div></footer><script src=https://blog.opencore.ch/assets/main.js></script>
<script src=https://blog.opencore.ch/assets/prism.js></script></div></body></html>