<!doctype html><html lang=en><head><title>Splitting a string into multiple lines in Solidity: How hard can it be? :: OpenCore Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?
Let&amp;rsquo;s assume that this is split up in an external function that takes a string and returns a string[] array containing the individual lines. A straight-forward implementation looks like this:
function lineSplit(string memory text) external pure returns (string[] memory) { bytes memory textBytes = bytes(text); uint lengthInBytes = textBytes."><meta name=keywords content="solidity"><meta name=robots content="noodp"><link rel=canonical href=https://blog.opencore.ch/posts/solidity-line-split/><link rel=stylesheet href=https://blog.opencore.ch/assets/style.css><link rel=stylesheet href=https://blog.opencore.ch/assets/blue.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://blog.opencore.ch/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://blog.opencore.ch/img/favicon/blue.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="romanboehr"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Splitting a string into multiple lines in Solidity: How hard can it be? :: OpenCore Blog"><meta property="og:description" content="For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?"><meta property="og:url" content="https://blog.opencore.ch/posts/solidity-line-split/"><meta property="og:site_name" content="Splitting a string into multiple lines in Solidity: How hard can it be?"><meta property="og:image" content="https://blog.opencore.ch"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-02-24 00:00:00 +0000 UTC"></head><body class=blue><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>OpenCore GmbH</div></a></div><div class=menu-trigger>menu</div></div></header><div class=content><div class=post><h1 class=post-title><a href=https://blog.opencore.ch/posts/solidity-line-split/>Splitting a string into multiple lines in Solidity: How hard can it be?</a></h1><div class=post-meta><span class=post-date>2023-02-24</span>
<span class=post-author>:: Roman Böhringer</span></div><span class=post-tags>#<a href=https://blog.opencore.ch/tags/solidity/>solidity</a>&nbsp;</span><div class=post-content><div><p>For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?</p><p>Let&rsquo;s assume that this is split up in an external function that takes a <code>string</code> and returns a <code>string[]</code> array containing the individual lines. A straight-forward implementation looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>lineSplit</span>(<span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span> text) <span style=color:#66d9ef>external</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> textBytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>bytes</span>(text);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lengthInBytes <span style=color:#f92672>=</span> textBytes.length;
</span></span><span style=display:flex><span>        require(lengthInBytes <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Invalid length&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lines <span style=color:#f92672>=</span> (lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span> strLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[](lines);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> bytesLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>bytes</span>(<span style=color:#ae81ff>40</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i; i <span style=color:#f92672>&lt;</span> lengthInBytes; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>%</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                strLines[i <span style=color:#f92672>/</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>(bytesLines);
</span></span><span style=display:flex><span>                bytesLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>bytes</span>(<span style=color:#ae81ff>40</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bytes1</span> character <span style=color:#f92672>=</span> textBytes[i];
</span></span><span style=display:flex><span>            bytesLines[i <span style=color:#f92672>%</span> <span style=color:#ae81ff>40</span>] <span style=color:#f92672>=</span> character;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        strLines[lines <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>(bytesLines);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> strLines;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>When we pass a few strings such as &ldquo;A&rdquo;, &ldquo;AAA&rdquo;, or &ldquo;A&rdquo; * 41, the results looks ok. However, what if our string contains a character like è? When passing the string <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAè</code>, we see the first problems: The function returns two lines, but the last character of the first line and the first of the second line are invalid. That&rsquo;s because è is a multi-byte character with the UTF-8 encoding <code>0xC3 0xA8</code>, but our implementation splits on bytes. We therefore need to adjust our implementation such that it does not split between multi-byte characters. This introduces a few complications:</p><ul><li>We no longer split the string into 40 characters, but (roughly) 40 bytes. While this is fine for our implementation, it may not be for others, in which case you would need to count the actual characters.</li><li>Each line can now have a different length (in bytes) as we need to include a few extra bytes (up to 3 extra bytes for 4 byte characters) when there is a multi-byte character at the end.</li></ul><p>Ok, let&rsquo;s rewrite the function such that it handles these complications correctly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>lineSplit2</span>(<span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span> text) <span style=color:#66d9ef>external</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> textBytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>bytes</span>(text);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lengthInBytes <span style=color:#f92672>=</span> textBytes.length;
</span></span><span style=display:flex><span>        require(lengthInBytes <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Invalid length&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lines <span style=color:#f92672>=</span> (lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span> strLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[](lines);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> prevByteWasContinuation;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> insertedLines;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> bytesLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>bytes</span>(<span style=color:#ae81ff>43</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> bytesOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i; i <span style=color:#f92672>&lt;</span> lengthInBytes; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bytes1</span> character <span style=color:#f92672>=</span> textBytes[i];
</span></span><span style=display:flex><span>            bytesLines[bytesOffset] <span style=color:#f92672>=</span> character;
</span></span><span style=display:flex><span>            bytesOffset<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> prevByteWasContinuation <span style=color:#f92672>||</span> i <span style=color:#f92672>==</span> lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bytes1</span> nextCharacter;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    nextCharacter <span style=color:#f92672>=</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (nextCharacter <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xC0</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Unicode continuation byte, top two bits are 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    prevByteWasContinuation <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Store the actual length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>assembly</span> {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>mstore</span>(bytesLines, bytesOffset)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    strLines<span style=color:#960050;background-color:#1e0010>[</span>insertedLines<span style=color:#960050;background-color:#1e0010>++]</span> <span style=color:#960050;background-color:#1e0010>=</span> string(bytesLines)<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    bytesLines <span style=color:#960050;background-color:#1e0010>=</span> new bytes(<span style=color:#ae81ff>43</span>)<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    prevByteWasContinuation <span style=color:#960050;background-color:#1e0010>=</span> false<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    bytesOffset <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> strLines;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Unicode continuation bytes are recognizable by the two top bits (which are 10 for them) and we can use inline assembly to change the length of the bytes array to the correct length before casting it to a string.</p><p>Strings like <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAè</code> or <code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAèè</code> are now correctly handled, nice! We can even use the functions for emojis, a string like 😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀😀 is correctly handled. However, something weird happens when we pass the string 👨‍👩‍👧‍👧👨‍👩‍👧‍👧👨‍👩‍👧‍👧. The output of the function is [👨‍👩‍👧‍👧👨‍👩‍👧, ‍👧👨‍👩‍👧‍👧]. Wait what, our function removed the daughter from the second family??? This happens because emojis like 👨‍👩‍👧‍👧 are composed of 4 individual emojis that are stitched together with a zero width joiner (<code>0xE2 0x80 0x8D</code>) and we potentially break on these joiners (which are individual UTF8 characters).</p><p>Ok, let&rsquo;s change the function such that it does not do that. Note that this also makes the lines potentially much longer (in bytes), so we have to allocate a larger buffer for it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>lineSplit3</span>(<span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span> text) <span style=color:#66d9ef>external</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> textBytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>bytes</span>(text);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lengthInBytes <span style=color:#f92672>=</span> textBytes.length;
</span></span><span style=display:flex><span>        require(lengthInBytes <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Invalid length&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lines <span style=color:#f92672>=</span> (lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span> strLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[](lines);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> prevByteWasContinuation;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> insertedLines;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> bytesLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>bytes</span>(<span style=color:#ae81ff>80</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> bytesOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i; i <span style=color:#f92672>&lt;</span> lengthInBytes; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bytes1</span> character <span style=color:#f92672>=</span> textBytes[i];
</span></span><span style=display:flex><span>            bytesLines[bytesOffset] <span style=color:#f92672>=</span> character;
</span></span><span style=display:flex><span>            bytesOffset<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> prevByteWasContinuation <span style=color:#f92672>||</span> i <span style=color:#f92672>==</span> lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bytes1</span> nextCharacter;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    nextCharacter <span style=color:#f92672>=</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (nextCharacter <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xC0</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Unicode continuation byte, top two bits are 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    prevByteWasContinuation <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Do not split when the prev. or next character is a zero width joiner. Otherwise, 👨‍👧‍👦 could become 👨&gt;‍👧‍👦
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Note that we do not need to check i &lt; lengthInBytes - 4, because we assume that it&#39;s a valid UTF8 string and these prefixes imply that another byte follows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        (nextCharacter <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xE2</span> <span style=color:#f92672>&amp;&amp;</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&amp;&amp;</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x8D</span>) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                        (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xE2</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x8D</span>)
</span></span><span style=display:flex><span>                    ) {
</span></span><span style=display:flex><span>                        prevByteWasContinuation <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Store the actual length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>assembly</span> {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>mstore</span>(bytesLines, bytesOffset)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    strLines<span style=color:#960050;background-color:#1e0010>[</span>insertedLines<span style=color:#960050;background-color:#1e0010>++]</span> <span style=color:#960050;background-color:#1e0010>=</span> string(bytesLines)<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    bytesLines <span style=color:#960050;background-color:#1e0010>=</span> new bytes(<span style=color:#ae81ff>80</span>)<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    prevByteWasContinuation <span style=color:#960050;background-color:#1e0010>=</span> false<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    bytesOffset <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> strLines;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Our function now returns [👨‍👩‍👧‍👧👨‍👩‍👧‍👧, 👨‍👩‍👧‍👧]. So did we develop the perfect Solidity line splitting function and can be proud? Let&rsquo;s do a last test with the string &ldquo;🤦🏿🤦🏿🤦🏿🤦🏿abcd🤦🏿&rdquo;. The function returns [🤦🏿🤦🏿🤦🏿🤦🏿abcd🤦, 🏿], which is not what we want! The problem here is that there is a skin tone modifier (without a zero width joiner) after the 🤦 and we split just between those characters. All right, let&rsquo;s fix that by avoiding splits before a <code>0xF0 0x9F 0x8F XY</code> where <code>XY</code> is <code>0xBB</code>, <code>0xBC</code>, <code>0xBD</code>, <code>0xBE</code>, <code>0xBF</code> (all possible skin tone modifiers):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span>    <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>lineSplit4</span>(<span style=color:#66d9ef>string</span> <span style=color:#66d9ef>memory</span> text) <span style=color:#66d9ef>external</span> <span style=color:#66d9ef>pure</span> <span style=color:#66d9ef>returns</span> (<span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> textBytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>bytes</span>(text);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lengthInBytes <span style=color:#f92672>=</span> textBytes.length;
</span></span><span style=display:flex><span>        require(lengthInBytes <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;Invalid length&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> lines <span style=color:#f92672>=</span> (lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>/</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span>[] <span style=color:#66d9ef>memory</span> strLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[](lines);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> prevByteWasContinuation;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint256</span> insertedLines;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bytes</span> <span style=color:#66d9ef>memory</span> bytesLines <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>bytes</span>(<span style=color:#ae81ff>80</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint</span> bytesOffset;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint</span> i; i <span style=color:#f92672>&lt;</span> lengthInBytes; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>bytes1</span> character <span style=color:#f92672>=</span> textBytes[i];
</span></span><span style=display:flex><span>            bytesLines[bytesOffset] <span style=color:#f92672>=</span> character;
</span></span><span style=display:flex><span>            bytesOffset<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((i <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>40</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> prevByteWasContinuation <span style=color:#f92672>||</span> i <span style=color:#f92672>==</span> lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>bytes1</span> nextCharacter;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>!=</span> lengthInBytes <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                    nextCharacter <span style=color:#f92672>=</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (nextCharacter <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xC0</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Unicode continuation byte, top two bits are 10
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    prevByteWasContinuation <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Do not split when the prev. or next character is a zero width joiner. Otherwise, 👨‍👧‍👦 could become 👨&gt;‍👧‍👦
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// Furthermore, do not split when next character is skin tone modifier to avoid 🤦‍♂️\n🏻
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Note that we do not need to check i &lt; lengthInBytes - 4, because we assume that it&#39;s a valid UTF8 string and these prefixes imply that another byte follows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        (nextCharacter <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xE2</span> <span style=color:#f92672>&amp;&amp;</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&amp;&amp;</span> textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x8D</span>) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                        (nextCharacter <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xF0</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x9F</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x8F</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>uint8</span>(textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>]) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>187</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>uint8</span>(textBytes[i <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>]) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>191</span>) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                        (i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0xE2</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x80</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                            textBytes[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x8D</span>)
</span></span><span style=display:flex><span>                    ) {
</span></span><span style=display:flex><span>                        prevByteWasContinuation <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Store the actual length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#66d9ef>assembly</span> {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>mstore</span>(bytesLines, bytesOffset)
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    strLines<span style=color:#960050;background-color:#1e0010>[</span>insertedLines<span style=color:#960050;background-color:#1e0010>++]</span> <span style=color:#960050;background-color:#1e0010>=</span> string(bytesLines)<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    bytesLines <span style=color:#960050;background-color:#1e0010>=</span> new bytes(<span style=color:#ae81ff>80</span>)<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    prevByteWasContinuation <span style=color:#960050;background-color:#1e0010>=</span> false<span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                    bytesOffset <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>;</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> strLines;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Now, this case is handled correctly as well. So is this the perfect Solidity line splitting algorithm that handles every input perfectly? No, definitely not. Unicode Line Breaking is very involved and <a href=https://unicode.org/reports/tr14/>there is a 25 paper annex on this topic</a>. While the algorithm handles some (commonly occuring) edge cases correctly, there are definitely others that could be problematic, especially with text in other characters (e.g., chinese ones).</p><p>** Note that all code in this post is not thoroughly tested and only used for illustrative purposes. Usage at your own risk **</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://blog.opencore.ch/posts/boost-python-cmake/><span class=button__text>Boost.Python: A minimal CMake Config</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 <a href=https://twitter.com/romanboehr/ target=_blank>Roman Böhringer</a></span></div></div></footer><script src=https://blog.opencore.ch/assets/main.js></script>
<script src=https://blog.opencore.ch/assets/prism.js></script></div></body></html>