<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on OpenCore Blog</title><link>https://blog.opencore.ch/posts/</link><description>Recent content in Posts on OpenCore Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 25 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.opencore.ch/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Setting up Metricbeat on a Docker Swarm Cluster</title><link>https://blog.opencore.ch/posts/metricbeat-docker-swarm-setup/</link><pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/metricbeat-docker-swarm-setup/</guid><description>To monitor your Docker swarm hosts (and containers) with Metricbeat, you can set up a global sidecar service. You need to mount the host&amp;rsquo;s filesystem, /sys/fs/cgroup, /proc, and /var/run/docker.sock inside the container to do so. An example compose file for the sidecar looks like this:
version: &amp;#39;3.7&amp;#39; services: metricbeat: image: docker.elastic.co/beats/metricbeat:7.16.1 user: root hostname: &amp;#34;{{.Node.Hostname}}-{{.Service.Name}}&amp;#34; configs: - source: metricbeat-config target: /usr/share/metricbeat/metricbeat.yml command: - -e - --strict.perms=false - --system.hostfs=/hostfs volumes: - type: bind source: / target: /hostfs read_only: true - type: bind source: /sys/fs/cgroup target: /hostfs/sys/fs/cgroup read_only: true - type: bind source: /proc target: /hostfs/proc read_only: true - type: bind source: /var/run/docker.</description></item><item><title>How to perform zero-copy S3 uploads with the AWS C++ SDK</title><link>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</guid><description>If you&amp;rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (as other developers did). You can write your own streambuf wrapper to do so, but if you&amp;rsquo;re already using boost in your project, boost::interprocess::bufferstream is a very straightforward way to do it:</description></item></channel></rss>