<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on OpenCore Blog</title><link>https://blog.opencore.ch/posts/</link><description>Recent content in Posts on OpenCore Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 24 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.opencore.ch/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Splitting a string into multiple lines in Solidity: How hard can it be?</title><link>https://blog.opencore.ch/posts/solidity-line-split/</link><pubDate>Fri, 24 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/solidity-line-split/</guid><description>For the on-chain SVG generation of an NFT, I recently needed to split an (arbitrary) string into multiple lines. Each line should contain 40 characters. Pretty easy, right?
Let&amp;rsquo;s assume that this is split up in an external function that takes a string and returns a string[] array containing the individual lines. A straight-forward implementation looks like this:
solidity function lineSplit(string memory text) external pure returns (string[] memory) { bytes memory textBytes = bytes(text); uint lengthInBytes = textBytes.</description></item><item><title>Boost.Python: A minimal CMake Config</title><link>https://blog.opencore.ch/posts/boost-python-cmake/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/boost-python-cmake/</guid><description>Although most of the examples and Boost&amp;rsquo;s documentation uses bjam, you can also use CMake for your Boost.Python projects. A minimal CMakeLists.txt to compile your Python library is provided below.
cmake_minimum_required(VERSION 3.10) project(yourlib) set(CMAKE_CXX_STANDARD 17) find_package(Boost COMPONENTS system python3 REQUIRED) find_package(Python3 COMPONENTS Interpreter Development REQUIRED) add_library(yourlib MODULE your_lib.cpp your_other_files.cpp) You may want to compile Boost as a static library such that you only have to ship one file. This can be achieved by providing cxxflags=&amp;quot;-fPIC&amp;quot; link=static install to b2 when compiling Boost from source.</description></item><item><title>Using SavaPage as a Frontend for uniFLOW</title><link>https://blog.opencore.ch/posts/savapage-uniflow/</link><pubDate>Wed, 12 Jan 2022 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/savapage-uniflow/</guid><description>A uniFLOW Queue (that is available over SMB) can be integrated quite easily into SavaPage with the CUPS SMB backend. To add it, simply run the following command on the SavaPage server:
lpadmin -p uniflow_queue -v smb://serviceaccount:servicepassword@domain/uniflow_server/uniflow_queue -P path/to/driver.ppd While this works, all print jobs will arrive at the uniFLOW server with the used serviceaccount. SavaPage sends the username of the user that submitted the job in the For attribute of the transmitted PostScript file.</description></item><item><title>Exposing C/C++ Data as a Python NumPy Array</title><link>https://blog.opencore.ch/posts/python-cpp-numpy-zero-copy/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/python-cpp-numpy-zero-copy/</guid><description>I recently needed to use memory that was allocated inside a C++ library in a Python application which expects a NumPy array without performing any copies. With ctypes, this can be implemented quite easily. Let&amp;rsquo;s say we have a shared library libcpp.so where a function get_shared_memory returns the pointer to an array of doubles that is stored on the heap:
cpp double* get_shared_memory(std::size_t num) { auto p = new double[num]; .</description></item><item><title>Setting up Metricbeat on a Docker Swarm Cluster</title><link>https://blog.opencore.ch/posts/metricbeat-docker-swarm-setup/</link><pubDate>Sat, 25 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/metricbeat-docker-swarm-setup/</guid><description>To monitor your Docker Swarm hosts (and containers) with Metricbeat, you can set up a global sidecar service. You need to mount the host&amp;rsquo;s filesystem, /sys/fs/cgroup, /proc, and /var/run/docker.sock inside the container to do so. An example compose file for the sidecar looks like this:
yaml docker-stack.yml version: &amp;#39;3.7&amp;#39; services: metricbeat: image: docker.elastic.co/beats/metricbeat:7.16.1 user: root hostname: &amp;#34;{{.Node.Hostname}}-{{.Service.Name}}&amp;#34; configs: - source: metricbeat-config target: /usr/share/metricbeat/metricbeat.yml command: - -e - --strict.perms=false - --system.hostfs=/hostfs volumes: - type: bind source: / target: /hostfs read_only: true - type: bind source: /sys/fs/cgroup target: /hostfs/sys/fs/cgroup read_only: true - type: bind source: /proc target: /hostfs/proc read_only: true - type: bind source: /var/run/docker.</description></item><item><title>How to perform zero-copy S3 uploads with the AWS C++ SDK</title><link>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</guid><description>If you&amp;rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (as other developers did). You can write your own streambuf wrapper to do so, but if you&amp;rsquo;re already using boost in your project, boost::interprocess::bufferstream is a very straightforward way to do it:</description></item><item><title>Unicode Normalization Forms: When รถ != รถ</title><link>https://blog.opencore.ch/posts/unicode-normalization-forms/</link><pubDate>Tue, 01 Jun 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/unicode-normalization-forms/</guid><description>Some time ago, a very weird issue was reported to me about a Nextcloud system. The user uploaded a file with an &amp;ldquo;รถ&amp;rdquo; on a SMB share that was configured as an external storage in the Nextcloud server. But when accessing the folder containing the file over WebDAV, it did not appear (no matter which WebDAV client was used). After ruling out the usual causes (wrong permissions, etc&amp;hellip;), I analyzed the network traffic between the WebDAV client and the server and saw that the file name is indeed not returned after issuing a PROPFIND.</description></item></channel></rss>