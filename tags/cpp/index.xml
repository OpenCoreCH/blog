<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on OpenCore Blog</title><link>https://blog.opencore.ch/tags/cpp/</link><description>Recent content in cpp on OpenCore Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.opencore.ch/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Boost.Python: A minimal CMake Config</title><link>https://blog.opencore.ch/posts/boost-python-cmake/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/boost-python-cmake/</guid><description>Although most of the examples and Boost&amp;rsquo;s documentation uses bjam, you can also use CMake for your Boost.Python projects. A minimal CMakeLists.txt to compile your Python library is provided below.
cmake_minimum_required(VERSION 3.10) project(yourlib) set(CMAKE_CXX_STANDARD 17) find_package(Boost COMPONENTS system python3 REQUIRED) find_package(Python3 COMPONENTS Interpreter Development REQUIRED) add_library(yourlib MODULE your_lib.cpp your_other_files.cpp) You may want to compile Boost as a static library such that you only have to ship one file. This can be achieved by providing cxxflags=&amp;quot;-fPIC&amp;quot; link=static install to b2 when compiling Boost from source.</description></item><item><title>Exposing C/C++ Data as a Python NumPy Array</title><link>https://blog.opencore.ch/posts/python-cpp-numpy-zero-copy/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/python-cpp-numpy-zero-copy/</guid><description>I recently needed to use memory that was allocated inside a C++ library in a Python application which expects a NumPy array without performing any copies. With ctypes, this can be implemented quite easily. Let&amp;rsquo;s say we have a shared library libcpp.so where a function get_shared_memory returns the pointer to an array of doubles that is stored on the heap:
cpp double* get_shared_memory(std::size_t num) { auto p = new double[num]; .</description></item><item><title>How to perform zero-copy S3 uploads with the AWS C++ SDK</title><link>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</guid><description>If you&amp;rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (as other developers did). You can write your own streambuf wrapper to do so, but if you&amp;rsquo;re already using boost in your project, boost::interprocess::bufferstream is a very straightforward way to do it:</description></item></channel></rss>