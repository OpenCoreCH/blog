<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cpp on Roman's Random Thoughts</title><link>https://blog.opencore.ch/tags/cpp/</link><description>Recent content in Cpp on Roman's Random Thoughts</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 13 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.opencore.ch/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Boost.Python: A minimal CMake Config</title><link>https://blog.opencore.ch/posts/boost-python-cmake/</link><pubDate>Thu, 13 Jan 2022 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/boost-python-cmake/</guid><description>&lt;p>Although most of the examples and Boost&amp;rsquo;s documentation uses &lt;code>bjam&lt;/code>, you can also use CMake for your Boost.Python projects. A minimal &lt;code>CMakeLists.txt&lt;/code> to compile your Python library is provided below.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>cmake_minimum_required(VERSION 3.10)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>project(yourlib)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set(CMAKE_CXX_STANDARD 17)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find_package(Boost COMPONENTS system python3 REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find_package(Python3 COMPONENTS Interpreter Development REQUIRED)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>add_library(yourlib MODULE your_lib.cpp your_other_files.cpp)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You may want to compile Boost as a static library such that you only have to ship one file. This can be achieved by providing &lt;code>cxxflags=&amp;quot;-fPIC&amp;quot; link=static install&lt;/code> to &lt;code>b2&lt;/code> when compiling Boost from source. I personally always use Docker containers (one for each Python version with the correct header files) and use the following command to integrate the statically-linked boost library into the container:&lt;/p></description></item><item><title>Exposing C/C++ Data as a Python NumPy Array</title><link>https://blog.opencore.ch/posts/python-cpp-numpy-zero-copy/</link><pubDate>Sun, 26 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/python-cpp-numpy-zero-copy/</guid><description>&lt;p>I recently needed to use memory that was allocated inside a C++ library in a Python application which expects a NumPy array without performing any copies. With &lt;code>ctypes&lt;/code>, this can be implemented quite easily.
Let&amp;rsquo;s say we have a shared library &lt;code>libcpp.so&lt;/code> where a function &lt;code>get_shared_memory&lt;/code> returns the pointer to an array of doubles that is stored on the heap:&lt;/p>



 &lt;div class="collapsable-code">
 &lt;input id="459236817" type="checkbox" />
 &lt;label for="459236817">
 &lt;span class="collapsable-code__language">cpp&lt;/span>
 
 &lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
 &lt;/label>
 &lt;pre class="language-cpp" >&lt;code>
double* get_shared_memory(std::size_t num) {
 auto p = new double[num];
 ...
 return p;
}
&lt;/code>&lt;/pre>
 &lt;/div>


&lt;p>The function can be called from Python with &lt;code>ctypes&lt;/code>:&lt;/p></description></item><item><title>How to perform zero-copy S3 uploads with the AWS C++ SDK</title><link>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</link><pubDate>Sat, 11 Dec 2021 00:00:00 +0000</pubDate><guid>https://blog.opencore.ch/posts/aws-cpp-sdk-zero-copy-upload/</guid><description>&lt;p>If you&amp;rsquo;re ever using the AWS C++ SDK in some constrained environment (such as Lambda functions with limited memory) or care about memory copies, you probably run into the issue of how to upload an existing buffer without copying it (&lt;a href="https://github.com/aws/aws-sdk-cpp/issues/64">as&lt;/a> &lt;a href="https://github.com/aws/aws-sdk-cpp/issues/533">other&lt;/a> &lt;a href="https://github.com/aws/aws-sdk-cpp/issues/785">developers&lt;/a> &lt;a href="https://github.com/aws/aws-sdk-cpp/issues/1430">did&lt;/a>).
You can write your own &lt;code>streambuf&lt;/code> wrapper to do so, but if you&amp;rsquo;re already using &lt;code>boost&lt;/code> in your project, &lt;code>boost::interprocess::bufferstream&lt;/code> is a very straightforward way to do it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> buf;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>size_t len;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>Aws&lt;span style="color:#f92672">::&lt;/span>IOStream&lt;span style="color:#f92672">&amp;gt;&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> Aws&lt;span style="color:#f92672">::&lt;/span>MakeShared&lt;span style="color:#f92672">&amp;lt;&lt;/span>boost&lt;span style="color:#f92672">::&lt;/span>interprocess&lt;span style="color:#f92672">::&lt;/span>bufferstream&lt;span style="color:#f92672">&amp;gt;&lt;/span>(TAG, buf, buf_len);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>data&lt;/code> can then be used as usual:&lt;/p></description></item></channel></rss>